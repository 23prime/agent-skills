# ブランク識別子

ブランク識別子(`_`)は、任意の型の任意の値を割り当てたり宣言したりでき、その値は無害に破棄される。これはUnixの`/dev/null`ファイルへの書き込みに似ている。変数が必要だが実際の値は無関係な場合のプレースホルダとして使用される書き込み専用の値を表す。

## 多重代入におけるブランク識別子

ブランク識別子は、不要な戻り値を破棄するために多重代入の状況で使用される。

```go
if _, err := os.Stat(path); os.IsNotExist(err) {
    fmt.Printf("%s does not exist\n", path)
}
```

**重要:** エラーを無視するためにエラー値を破棄してはいけない。常にエラーの戻り値をチェックすること。

```go
// 悪い例! pathが存在しない場合、このコードはクラッシュする
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf("%s is a directory\n", path)
}
```

## 未使用のインポートと変数

パッケージをインポートしたり変数を宣言したりしたまま使わないのはエラーである。未使用のインポートはプログラムを肥大化させ、コンパイルを遅くする。プログラムが活発に開発されている間、ブランク識別子は回避策を提供する。

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

var _ = fmt.Printf // デバッグ用。完了したら削除
var _ io.Reader    // デバッグ用。完了したら削除

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: fdを使う
    _ = fd
}
```

慣例として、インポートエラーを抑制するグローバル宣言は、インポートの直後に置き、コメントを付けるべきである。これにより見つけやすくなり、後で整理するリマインダーとなる。

## 副作用のためのインポート

副作用のためだけにパッケージをインポートし、明示的に使用しないことが有用な場合がある。例えば、`net/http/pprof`パッケージは`init`関数でデバッグ情報を提供するHTTPハンドラを登録する。副作用のためだけにパッケージをインポートするには、ブランク識別子にリネームする。

```go
import _ "net/http/pprof"
```

このインポート形式は、パッケージが副作用のためにインポートされていることを明確にする。このファイルではパッケージの他の使い道がないためだ。つまり、このファイルでは名前を持たない。

## インターフェースチェック

型がインターフェースを実装することを明示的に宣言する必要はない。代わりに、型はそのメソッドを実装するだけでインターフェースを実装する。ほとんどのインターフェース変換は静的でコンパイル時にチェックされる。しかし、実行時に行われるインターフェースチェックもある。

パッケージ内で型が実際にインターフェースを満たすことを保証する必要がある場合、ブランク識別子を使ったグローバル宣言を使用する。

```go
var _ json.Marshaler = (*RawMessage)(nil)
```

この宣言では、`*RawMessage`から`Marshaler`への変換を含む代入により、`*RawMessage`が`Marshaler`を実装することが要求され、このプロパティはコンパイル時にチェックされる。`json.Marshaler`インターフェースが変更された場合、このパッケージはもはやコンパイルできなくなり、更新が必要であることが通知される。

この構造でブランク識別子が現れることは、この宣言が変数を作成するためではなく、型チェックのためだけに存在することを示している。慣例として、このような宣言は、コードに静的な変換がすでに存在しない場合にのみ使用され、これは稀な出来事である。
