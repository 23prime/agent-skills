# スキル作成のベストプラクティス

Claude が発見し、効果的に使用できるスキルの書き方を学びます。

優れたスキルは、簡潔で、構造が整っており、実際の使用でテストされています。
このガイドでは、Claude が発見し効果的に使用できるスキルを書くための実践的な
判断基準を提供します。

## 基本原則

### 簡潔さが鍵

コンテキストウィンドウは公共財です。スキルは、Claude が知る必要のある他の
すべてのものとコンテキストウィンドウを共有します。これには以下が含まれます:

- システムプロンプト
- 会話履歴
- 他のスキルのメタデータ
- 実際のリクエスト

スキル内のすべてのトークンに即時コストがかかるわけではありません。起動時には、
すべてのスキルからメタデータ（名前と説明）のみが事前に読み込まれます。Claude は
スキルが関連する場合にのみ SKILL.md を読み、追加ファイルは必要に応じて読み込み
ます。ただし、SKILL.md を簡潔に保つことは依然として重要です。Claude がそれを
読み込むと、すべてのトークンが会話履歴や他のコンテキストと競合します。

**デフォルトの前提**: Claude はすでに非常に賢い

Claude がまだ持っていないコンテキストのみを追加してください。各情報に
ついて以下を確認します:

- 「Claude は本当にこの説明が必要か？」
- 「Claude はこれを知っていると仮定できるか？」
- 「この段落はトークンコストに見合うか？」

**良い例: 簡潔**（約 50 トークン）:

```markdown
## PDF テキスト抽出

テキスト抽出には pdfplumber を使用:

import pdfplumber

with pdfplumber.open("file.pdf") as pdf:
    text = pdf.pages[0].extract_text()
```

**悪い例: 冗長すぎる**（約 150 トークン）:

```markdown
## PDF テキスト抽出

PDF（Portable Document Format）ファイルは、テキスト、画像、その他の
コンテンツを含む一般的なファイル形式です。PDF からテキストを抽出するには、
ライブラリを使用する必要があります。PDF 処理には多くのライブラリがありますが、
使いやすくほとんどのケースをうまく処理できる pdfplumber をお勧めします。
まず、pip を使用してインストールする必要があります。次に、以下のコードを
使用できます...
```

簡潔なバージョンは、Claude が PDF とは何か、ライブラリがどのように機能するかを
知っていることを前提としています。

### 適切な自由度の設定

タスクの脆弱性と変動性に応じて、具体性のレベルを調整します。

**高い自由度**（テキストベースの指示）:

使用する場面:

- 複数のアプローチが有効な場合
- 決定がコンテキストに依存する場合
- ヒューリスティクスがアプローチを導く場合

例:

```markdown
## コードレビュープロセス

1. コードの構造と構成を分析
2. 潜在的なバグやエッジケースをチェック
3. 可読性と保守性の改善を提案
4. プロジェクトの規約への準拠を確認
```

**中程度の自由度**（擬似コードまたはパラメータ付きスクリプト）:

使用する場面:

- 推奨パターンが存在する場合
- ある程度のバリエーションが許容される場合
- 設定が動作に影響する場合

例:

```markdown
## レポート生成

このテンプレートを使用し、必要に応じてカスタマイズ:

def generate_report(data, format="markdown", include_charts=True):
    # データを処理
    # 指定された形式で出力を生成
    # オプションで可視化を含める
```

**低い自由度**（特定のスクリプト、パラメータなしまたは少数）:

使用する場面:

- 操作が脆弱でエラーが発生しやすい場合
- 一貫性が重要な場合
- 特定のシーケンスに従う必要がある場合

例:

```markdown
## データベースマイグレーション

このスクリプトを正確に実行:

python scripts/migrate.py --verify --backup

コマンドを変更したり、追加のフラグを追加しないこと。
```

**アナロジー**: Claude を道を探索するロボットとして考える:

- **両側に崖がある狭い橋**: 安全な道は一つだけ。具体的なガードレールと正確な
  指示を提供（低い自由度）。例: 正確な順序で実行する必要があるデータベース
  マイグレーション。
- **危険のない開けた野原**: 多くの道が成功につながる。一般的な方向を示し、
  Claude が最良のルートを見つけることを信頼（高い自由度）。例: コンテキストが
  最適なアプローチを決定するコードレビュー。

### 使用予定のすべてのモデルでテスト

スキルはモデルへの追加として機能するため、効果は基盤となるモデルに依存します。
使用予定のすべてのモデルでスキルをテストしてください。

**モデル別のテスト考慮事項**:

- **Claude Haiku**（高速、経済的）: スキルは十分なガイダンスを提供しているか？
- **Claude Sonnet**（バランス）: スキルは明確で効率的か？
- **Claude Opus**（強力な推論）: スキルは過度に説明していないか？

Opus で完璧に機能するものでも、Haiku ではより詳細が必要な場合があります。
複数のモデルでスキルを使用する予定がある場合は、すべてで適切に機能する
指示を目指してください。

## スキルの構造

### YAML フロントマター

SKILL.md のフロントマターには 2 つのフィールドが必要です:

**name**:

- 最大 64 文字
- 小文字、数字、ハイフンのみ使用可能
- XML タグを含むことはできない
- 予約語を含むことはできない: "anthropic", "claude"

**description**:

- 空でないこと
- 最大 1024 文字
- XML タグを含むことはできない
- スキルが何をするか、いつ使用するかを説明すること

### 命名規則

スキルを参照しやすく、議論しやすくするために、一貫した命名パターンを使用します。
スキル名には**動名詞形**（動詞 + -ing）を使用することをお勧めします。これにより、
スキルが提供する活動や機能が明確に説明されます。

`name` フィールドは小文字、数字、ハイフンのみを使用する必要があることを
忘れないでください。

**良い命名例（動名詞形）**:

- `processing-pdfs`
- `analyzing-spreadsheets`
- `managing-databases`
- `testing-code`
- `writing-documentation`

**許容される代替案**:

- 名詞句: `pdf-processing`, `spreadsheet-analysis`
- アクション指向: `process-pdfs`, `analyze-spreadsheets`

**避けるべき命名**:

- 曖昧な名前: `helper`, `utils`, `tools`
- 過度に一般的: `documents`, `data`, `files`
- 予約語: `anthropic-helper`, `claude-tools`
- スキルコレクション内での一貫性のないパターン

一貫した命名により:

- ドキュメントや会話でスキルを参照しやすくなる
- スキルが何をするかを一目で理解できる
- 複数のスキルを整理・検索しやすくなる
- プロフェッショナルで一貫したスキルライブラリを維持できる

### 効果的な説明の書き方

`description` フィールドはスキルの発見を可能にし、スキルが何をするか、
いつ使用するかの両方を含める必要があります。

> **常に三人称で書く**。説明はシステムプロンプトに挿入され、視点の不一致は
> 発見の問題を引き起こす可能性があります。
>
> - **良い:** "Excel ファイルを処理し、レポートを生成する"
> - **避ける:** "Excel ファイルの処理をお手伝いします"
> - **避ける:** "これを使って Excel ファイルを処理できます"

**具体的にキーワードを含める**。スキルが何をするか、いつ使用するかの具体的な
トリガー/コンテキストを含めます。

各スキルには説明フィールドが 1 つだけあります。説明はスキル選択にとって重要です。
Claude は潜在的に 100 以上の利用可能なスキルから適切なスキルを選択するために
これを使用します。説明は Claude がこのスキルをいつ選択すべきかを知るのに
十分な詳細を提供する必要があり、SKILL.md の残りの部分が実装の詳細を提供します。

**効果的な例**:

PDF 処理スキル:

```yaml
description: PDF ファイルからテキストとテーブルを抽出し、フォームに入力し、ドキュメントをマージする。PDF ファイルを扱う場合や、ユーザーが PDF、フォーム、ドキュメント抽出について言及した場合に使用。
```

Excel 分析スキル:

```yaml
description: Excel スプレッドシートを分析し、ピボットテーブルを作成し、チャートを生成する。Excel ファイル、スプレッドシート、表形式データ、.xlsx ファイルを分析する場合に使用。
```

Git コミットヘルパースキル:

```yaml
description: git diff を分析して説明的なコミットメッセージを生成する。ユーザーがコミットメッセージの作成やステージされた変更のレビューを求めた場合に使用。
```

**曖昧な説明は避ける**:

```yaml
description: ドキュメントを扱う
```

```yaml
description: データを処理する
```

```yaml
description: ファイルで何かをする
```

### 段階的開示パターン

SKILL.md は、オンボーディングガイドの目次のように、必要に応じて詳細な資料を
指し示す概要として機能します。

**実践的なガイダンス:**

- 最適なパフォーマンスのために SKILL.md 本文を 500 行未満に保つ
- この制限に近づいたらコンテンツを別ファイルに分割
- 以下のパターンを使用して指示、コード、リソースを効果的に整理

#### 視覚的概要: シンプルから複雑へ

基本的なスキルは、メタデータと指示を含む SKILL.md ファイルのみで始まります。

スキルが成長するにつれて、Claude が必要なときにのみ読み込む追加コンテンツを
バンドルできます。

完全なスキルディレクトリ構造は次のようになります:

```txt
pdf/
├── SKILL.md              # メイン指示（トリガー時に読み込み）
├── FORMS.md              # フォーム入力ガイド（必要に応じて読み込み）
├── reference.md          # API リファレンス（必要に応じて読み込み）
├── examples.md           # 使用例（必要に応じて読み込み）
└── scripts/
    ├── analyze_form.py   # ユーティリティスクリプト（実行、読み込みなし）
    ├── fill_form.py      # フォーム入力スクリプト
    └── validate.py       # 検証スクリプト
```

#### パターン 1: 参照付きハイレベルガイド

```markdown
---
name: pdf-processing
description: PDF ファイルからテキストとテーブルを抽出し、フォームに入力し、ドキュメントをマージする。PDF ファイルを扱う場合や、ユーザーが PDF、フォーム、ドキュメント抽出について言及した場合に使用。
---

# PDF 処理

## クイックスタート

pdfplumber でテキストを抽出:

import pdfplumber
with pdfplumber.open("file.pdf") as pdf:
    text = pdf.pages[0].extract_text()

## 高度な機能

**フォーム入力**: 完全なガイドは [FORMS.md](FORMS.md) を参照
**API リファレンス**: すべてのメソッドは [REFERENCE.md](REFERENCE.md) を参照
**例**: 一般的なパターンは [EXAMPLES.md](EXAMPLES.md) を参照
```

Claude は必要な場合にのみ FORMS.md、REFERENCE.md、または EXAMPLES.md を
読み込みます。

#### パターン 2: ドメイン固有の構成

複数のドメインを持つスキルの場合、無関係なコンテキストの読み込みを避けるために
ドメインごとにコンテンツを整理します。ユーザーが売上指標について質問した場合、
Claude は財務やマーケティングデータではなく、売上関連のスキーマのみを読み込む
必要があります。これにより、トークン使用量が低く保たれ、コンテキストが
集中します。

```txt
bigquery-skill/
├── SKILL.md (概要とナビゲーション)
└── reference/
    ├── finance.md (収益、請求指標)
    ├── sales.md (商談、パイプライン)
    ├── product.md (API 使用状況、機能)
    └── marketing.md (キャンペーン、アトリビューション)
```

SKILL.md:

```markdown
# BigQuery データ分析

## 利用可能なデータセット

**財務**: 収益、ARR、請求 → [reference/finance.md](reference/finance.md) を参照
**営業**: 商談、パイプライン、アカウント → [reference/sales.md](reference/sales.md) を参照
**プロダクト**: API 使用状況、機能、採用 → [reference/product.md](reference/product.md) を参照
**マーケティング**: キャンペーン、アトリビューション、メール → [reference/marketing.md](reference/marketing.md) を参照

## クイック検索

grep を使用して特定の指標を検索:

grep -i "revenue" reference/finance.md
grep -i "pipeline" reference/sales.md
grep -i "api usage" reference/product.md
```

#### パターン 3: 条件付き詳細

基本コンテンツを表示し、高度なコンテンツにリンク:

```markdown
# DOCX 処理

## ドキュメントの作成

新しいドキュメントには docx-js を使用。[DOCX-JS.md](DOCX-JS.md) を参照。

## ドキュメントの編集

単純な編集の場合、XML を直接変更。

**変更履歴**: [REDLINING.md](REDLINING.md) を参照
**OOXML の詳細**: [OOXML.md](OOXML.md) を参照
```

Claude はユーザーがこれらの機能を必要とする場合にのみ REDLINING.md または
OOXML.md を読み込みます。

### 深くネストされた参照を避ける

Claude は、他の参照ファイルから参照されているファイルを部分的に読み込む場合が
あります。ネストされた参照に遭遇すると、Claude は完全なファイルを読み込む代わりに
`head -100` のようなコマンドを使用してコンテンツをプレビューし、不完全な情報に
なる可能性があります。

**参照は SKILL.md から 1 レベルの深さに保つ**。すべての参照ファイルは SKILL.md
から直接リンクして、Claude が必要なときに完全なファイルを読み込むようにします。

**悪い例: 深すぎる**:

```markdown
# SKILL.md
[advanced.md](advanced.md) を参照...

# advanced.md
[details.md](details.md) を参照...

# details.md
実際の情報はここ...
```

**良い例: 1 レベルの深さ**:

```markdown
# SKILL.md

**基本的な使用方法**: [SKILL.md 内の指示]
**高度な機能**: [advanced.md](advanced.md) を参照
**API リファレンス**: [reference.md](reference.md) を参照
**例**: [examples.md](examples.md) を参照
```

### 長い参照ファイルには目次を付ける

100 行を超える参照ファイルの場合、先頭に目次を含めます。これにより、Claude が
部分的な読み込みでプレビューしている場合でも、利用可能な情報の全範囲を
確認できます。

**例**:

```markdown
# API リファレンス

## 目次

- 認証とセットアップ
- コアメソッド（create、read、update、delete）
- 高度な機能（バッチ操作、webhook）
- エラーハンドリングパターン
- コード例

## 認証とセットアップ
...

## コアメソッド
...
```

Claude は完全なファイルを読み込むか、必要に応じて特定のセクションに
ジャンプできます。

## ワークフローとフィードバックループ

### 複雑なタスクにはワークフローを使用

複雑な操作を明確で順次的なステップに分解します。特に複雑なワークフローの場合、
Claude が応答にコピーして進捗に応じてチェックできるチェックリストを提供します。

**例 1: 調査統合ワークフロー**（コードなしのスキル向け）:

```markdown
## 調査統合ワークフロー

このチェックリストをコピーして進捗を追跡:

調査の進捗:
- [ ] ステップ 1: すべてのソースドキュメントを読む
- [ ] ステップ 2: 主要なテーマを特定
- [ ] ステップ 3: 主張を相互参照
- [ ] ステップ 4: 構造化された要約を作成
- [ ] ステップ 5: 引用を確認

**ステップ 1: すべてのソースドキュメントを読む**

`sources/` ディレクトリ内の各ドキュメントを確認。主な議論と裏付けとなる証拠をメモ。

**ステップ 2: 主要なテーマを特定**

ソース間のパターンを探す。どのテーマが繰り返し現れるか？ソース間で同意または不同意はどこか？

**ステップ 3: 主張を相互参照**

各主要な主張について、ソース資料に記載されていることを確認。どのソースが各ポイントを支持しているかをメモ。

**ステップ 4: 構造化された要約を作成**

調査結果をテーマ別に整理。含めるもの:
- 主な主張
- ソースからの裏付けとなる証拠
- 対立する見解（ある場合）

**ステップ 5: 引用を確認**

すべての主張が正しいソースドキュメントを参照していることを確認。引用が不完全な場合、ステップ 3 に戻る。
```

この例は、コードを必要としない分析タスクにワークフローがどのように適用されるかを
示しています。チェックリストパターンは、複雑な複数ステップのプロセスに有効です。

**例 2: PDF フォーム入力ワークフロー**（コード付きスキル向け）:

```markdown
## PDF フォーム入力ワークフロー

このチェックリストをコピーして完了したらチェック:

タスクの進捗:
- [ ] ステップ 1: フォームを分析（analyze_form.py を実行）
- [ ] ステップ 2: フィールドマッピングを作成（fields.json を編集）
- [ ] ステップ 3: マッピングを検証（validate_fields.py を実行）
- [ ] ステップ 4: フォームに入力（fill_form.py を実行）
- [ ] ステップ 5: 出力を確認（verify_output.py を実行）

**ステップ 1: フォームを分析**

実行: `python scripts/analyze_form.py input.pdf`

フォームフィールドとその位置を抽出し、`fields.json` に保存。

**ステップ 2: フィールドマッピングを作成**

`fields.json` を編集して各フィールドに値を追加。

**ステップ 3: マッピングを検証**

実行: `python scripts/validate_fields.py fields.json`

続行する前に検証エラーを修正。

**ステップ 4: フォームに入力**

実行: `python scripts/fill_form.py input.pdf fields.json output.pdf`

**ステップ 5: 出力を確認**

実行: `python scripts/verify_output.py output.pdf`

検証に失敗した場合、ステップ 2 に戻る。
```

明確なステップにより、Claude が重要な検証をスキップすることを防ぎます。
チェックリストは、Claude とあなたの両方が複数ステップのワークフローの
進捗を追跡するのに役立ちます。

### フィードバックループの実装

**一般的なパターン**: バリデータを実行 → エラーを修正 → 繰り返し

このパターンは出力品質を大幅に向上させます。

**例 1: スタイルガイドへの準拠**（コードなしのスキル向け）:

```markdown
## コンテンツレビュープロセス

1. STYLE_GUIDE.md のガイドラインに従ってコンテンツを作成
2. チェックリストに対してレビュー:
   - 用語の一貫性を確認
   - 例が標準形式に従っていることを確認
   - すべての必須セクションが存在することを確認
3. 問題が見つかった場合:
   - 特定のセクション参照とともに各問題をメモ
   - コンテンツを修正
   - チェックリストを再度確認
4. すべての要件が満たされた場合にのみ続行
5. ドキュメントを確定して保存
```

これは、スクリプトの代わりに参照ドキュメントを使用した検証ループパターンを
示しています。「バリデータ」は STYLE_GUIDE.md であり、Claude は読み取りと
比較によってチェックを実行します。

**例 2: ドキュメント編集プロセス**（コード付きスキル向け）:

```markdown
## ドキュメント編集プロセス

1. `word/document.xml` を編集
2. **即座に検証**: `python ooxml/scripts/validate.py unpacked_dir/`
3. 検証に失敗した場合:
   - エラーメッセージを注意深く確認
   - XML の問題を修正
   - 検証を再実行
4. **検証に合格した場合にのみ続行**
5. 再構築: `python ooxml/scripts/pack.py unpacked_dir/ output.docx`
6. 出力ドキュメントをテスト
```

検証ループによりエラーを早期にキャッチします。

## コンテンツガイドライン

### 時間依存情報を避ける

古くなる情報を含めないでください:

**悪い例: 時間依存**（間違いになる）:

```markdown
2025 年 8 月より前にこれを行う場合は、古い API を使用してください。
2025 年 8 月以降は、新しい API を使用してください。
```

**良い例**（「古いパターン」セクションを使用）:

```markdown
## 現在の方法

v2 API エンドポイントを使用: `api.example.com/v2/messages`

## 古いパターン

<details>
<summary>レガシー v1 API（2025-08 に非推奨）</summary>

v1 API は以下を使用: `api.example.com/v1/messages`

このエンドポイントはサポートされなくなりました。
</details>
```

古いパターンセクションは、メインコンテンツを乱雑にせずに履歴コンテキストを
提供します。

### 一貫した用語を使用

1 つの用語を選び、スキル全体で使用します:

**良い - 一貫性あり**:

- 常に「API エンドポイント」
- 常に「フィールド」
- 常に「抽出」

**悪い - 一貫性なし**:

- 「API エンドポイント」「URL」「API ルート」「パス」の混在
- 「フィールド」「ボックス」「要素」「コントロール」の混在
- 「抽出」「プル」「取得」「リトリーブ」の混在

一貫性により Claude が指示を理解し、従いやすくなります。

## 一般的なパターン

### テンプレートパターン

出力形式のテンプレートを提供します。必要に応じて厳格さのレベルを調整します。

**厳格な要件の場合**（API レスポンスやデータ形式など）:

```markdown
## レポート構造

必ずこの正確なテンプレート構造を使用:

# [分析タイトル]

## エグゼクティブサマリー
[主要な調査結果の 1 段落の概要]

## 主要な調査結果
- 裏付けデータを含む調査結果 1
- 裏付けデータを含む調査結果 2
- 裏付けデータを含む調査結果 3

## 推奨事項
1. 具体的で実行可能な推奨事項
2. 具体的で実行可能な推奨事項
```

**柔軟なガイダンスの場合**（適応が有用な場合）:

```markdown
## レポート構造

以下は妥当なデフォルト形式ですが、分析に基づいて最善の判断を使用:

# [分析タイトル]

## エグゼクティブサマリー
[概要]

## 主要な調査結果
[発見に基づいてセクションを適応]

## 推奨事項
[特定のコンテキストに合わせて調整]

特定の分析タイプに応じてセクションを調整。
```

### 例示パターン

出力品質が例を見ることに依存するスキルの場合、通常のプロンプティングと
同様に入力/出力のペアを提供します:

```markdown
## コミットメッセージ形式

以下の例に従ってコミットメッセージを生成:

**例 1:**
入力: JWT トークンによるユーザー認証を追加
出力:
feat(auth): JWT ベースの認証を実装

ログインエンドポイントとトークン検証ミドルウェアを追加

**例 2:**
入力: レポートで日付が正しく表示されないバグを修正
出力:
fix(reports): タイムゾーン変換での日付フォーマットを修正

レポート生成全体で UTC タイムスタンプを一貫して使用

**例 3:**
入力: 依存関係を更新し、エラーハンドリングをリファクタリング
出力:
chore: 依存関係を更新し、エラーハンドリングをリファクタリング

- lodash を 4.17.21 にアップグレード
- エンドポイント全体でエラーレスポンス形式を標準化

このスタイルに従う: type(scope): 簡潔な説明、その後詳細な説明。
```

例は、説明だけよりも Claude が望ましいスタイルと詳細レベルを理解するのに
役立ちます。

### 条件付きワークフローパターン

Claude を決定ポイントを通じてガイドします:

```markdown
## ドキュメント変更ワークフロー

1. 変更タイプを決定:

   **新しいコンテンツを作成？** → 以下の「作成ワークフロー」に従う
   **既存のコンテンツを編集？** → 以下の「編集ワークフロー」に従う

2. 作成ワークフロー:
   - docx-js ライブラリを使用
   - ゼロからドキュメントを構築
   - .docx 形式でエクスポート

3. 編集ワークフロー:
   - 既存のドキュメントを展開
   - XML を直接変更
   - 各変更後に検証
   - 完了したら再パック
```

ワークフローが多くのステップで大きくなったり複雑になったりした場合、
別のファイルに押し出し、タスクに応じて Claude に適切なファイルを読むよう
指示することを検討してください。

## 評価と反復

### まず評価を構築

**広範なドキュメントを書く前に評価を作成**。これにより、スキルが想像上の問題
ではなく、実際の問題を解決することが保証されます。

**評価駆動開発:**

1. **ギャップを特定**: スキルなしで代表的なタスクで Claude を実行。
   具体的な失敗や不足しているコンテキストを文書化
2. **評価を作成**: これらのギャップをテストする 3 つのシナリオを構築
3. **ベースラインを確立**: スキルなしで Claude のパフォーマンスを測定
4. **最小限の指示を書く**: ギャップに対処し、評価に合格するのに十分な
   コンテンツのみを作成
5. **反復**: 評価を実行し、ベースラインと比較して改善

このアプローチにより、実現しない可能性のある要件を予測するのではなく、
実際の問題を解決することが保証されます。

**評価の構造**:

```json
{
  "skills": ["pdf-processing"],
  "query": "この PDF ファイルからすべてのテキストを抽出し、output.txt に保存",
  "files": ["test-files/document.pdf"],
  "expected_behavior": [
    "適切な PDF 処理ライブラリまたはコマンドラインツールを使用して PDF ファイルを正常に読み取る",
    "ドキュメント内のすべてのページからテキストコンテンツを抽出し、ページを見逃さない",
    "抽出されたテキストを明確で読みやすい形式で output.txt というファイルに保存"
  ]
}
```

評価はスキルの効果を測定するための信頼できる情報源です。

### Claude との反復的なスキル開発

最も効果的なスキル開発プロセスには Claude 自体が関与します。あるインスタンスの
Claude（「Claude A」）と協力して、他のインスタンス（「Claude B」）が使用する
スキルを作成します。Claude A は指示の設計と改善を支援し、Claude B は実際の
タスクでそれをテストします。これは、Claude モデルが効果的なエージェント指示の
書き方とエージェントが必要とする情報の両方を理解しているため機能します。

**新しいスキルの作成:**

1. **スキルなしでタスクを完了**: 通常のプロンプティングを使用して Claude A と
   問題を解決。作業中、自然にコンテキストを提供し、好みを説明し、手続き的な
   知識を共有します。繰り返し提供する情報に注目。

2. **再利用可能なパターンを特定**: タスクを完了した後、将来の類似タスクに
   役立つ提供したコンテキストを特定。

   **例**: BigQuery 分析を行った場合、テーブル名、フィールド定義、フィルタリング
   ルール（「常にテストアカウントを除外」など）、一般的なクエリパターンを
   提供した可能性があります。

3. **Claude A にスキルの作成を依頼**: 「使用した BigQuery 分析パターンを
   キャプチャするスキルを作成してください。テーブルスキーマ、命名規則、
   テストアカウントのフィルタリングルールを含めてください。」

   Claude モデルはスキルの形式と構造をネイティブに理解しています。Claude に
   スキルの作成を依頼するために特別なシステムプロンプトや「スキルを書く」
   スキルは必要ありません。単に Claude にスキルを作成するよう依頼すれば、
   適切なフロントマターと本文コンテンツを含む適切に構造化された SKILL.md
   コンテンツが生成されます。

4. **簡潔さをレビュー**: Claude A が不要な説明を追加していないか確認。
   「勝率が何を意味するかの説明を削除してください - Claude はすでにそれを
   知っています。」

5. **情報アーキテクチャを改善**: Claude A にコンテンツをより効果的に整理
   するよう依頼。例: 「テーブルスキーマが別の参照ファイルにあるように
   整理してください。後でテーブルを追加する可能性があります。」

6. **類似タスクでテスト**: スキルが読み込まれた Claude B（スキルが読み込まれた
   新しいインスタンス）を関連するユースケースで使用。Claude B が適切な情報を
   見つけ、ルールを正しく適用し、タスクを正常に処理しているかを観察。

7. **観察に基づいて反復**: Claude B が苦労したり何かを見逃したりした場合、
   具体的な内容を持って Claude A に戻る: 「Claude がこのスキルを使用した際、
   Q4 の日付でフィルタリングするのを忘れました。日付フィルタリングパターンに
   ついてのセクションを追加すべきでしょうか？」

**既存スキルの反復:**

スキルを改善する際も同じ階層的なパターンが続きます。以下を交互に行います:

- **Claude A と作業**（スキルの改善を支援するエキスパート）
- **Claude B でテスト**（実際の作業を行うスキルを使用するエージェント）
- **Claude B の動作を観察**し、洞察を Claude A に持ち帰る

1. **実際のワークフローでスキルを使用**: Claude B（スキルが読み込まれた状態）に
   テストシナリオではなく、実際のタスクを与える

2. **Claude B の動作を観察**: 苦労している場所、成功している場所、予期しない
   選択をしている場所をメモ

   **観察例**: 「Claude B に地域別売上レポートを依頼したとき、クエリを書きましたが、
   スキルがこのルールに言及しているにもかかわらず、テストアカウントを
   フィルタリングするのを忘れました。」

3. **Claude A に改善のために戻る**: 現在の SKILL.md を共有し、観察したことを
   説明。「地域レポートを依頼したとき、Claude B がテストアカウントを
   フィルタリングするのを忘れたことに気づきました。スキルはフィルタリングに
   言及していますが、十分に目立っていないのかもしれません。」

4. **Claude A の提案をレビュー**: Claude A は、ルールをより目立たせるための
   再構成、「always filter」の代わりに「MUST filter」のような強い言葉の使用、
   またはワークフローセクションの再構築を提案するかもしれません。

5. **変更を適用してテスト**: Claude A の改善でスキルを更新し、Claude B で
   類似のリクエストを再度テスト

6. **使用に基づいて繰り返し**: 新しいシナリオに遭遇するたびに、この
   観察-改善-テストサイクルを続けます。各反復は、仮定ではなく実際のエージェントの
   動作に基づいてスキルを改善します。

**チームフィードバックの収集:**

1. チームメイトとスキルを共有し、使用状況を観察
2. 質問: スキルは期待通りにアクティブになるか？指示は明確か？何が不足しているか？
3. フィードバックを取り入れて、自分の使用パターンの盲点に対処

**このアプローチが機能する理由**: Claude A はエージェントのニーズを理解し、
あなたはドメインの専門知識を提供し、Claude B は実際の使用を通じてギャップを
明らかにし、反復的な改善は仮定ではなく観察された動作に基づいてスキルを
改善します。

### Claude がスキルをナビゲートする方法を観察

スキルを反復する際、Claude が実際にどのように使用しているかに注意を払います。
以下を監視:

- **予期しない探索パス**: Claude が予期しない順序でファイルを読んでいるか？
  これは構造が思ったほど直感的でないことを示す可能性があります
- **見逃された接続**: Claude が重要なファイルへの参照に従わないか？リンクを
  より明示的または目立つようにする必要があるかもしれません
- **特定のセクションへの過度の依存**: Claude が同じファイルを繰り返し読んでいる
  場合、そのコンテンツをメインの SKILL.md に含めるべきか検討
- **無視されたコンテンツ**: Claude がバンドルされたファイルにアクセスしない場合、
  それは不要であるか、メインの指示でシグナルが適切でない可能性があります

仮定ではなく、これらの観察に基づいて反復します。スキルのメタデータの「name」と
「description」は特に重要です。Claude は現在のタスクに応じてスキルをトリガー
するかどうかを決定する際にこれらを使用します。スキルが何をするか、いつ使用
すべきかを明確に説明してください。

## 避けるべきアンチパターン

### Windows スタイルのパスを避ける

Windows でも常にファイルパスにスラッシュを使用:

- **良い**: `scripts/helper.py`, `reference/guide.md`
- **避ける**: `scripts\helper.py`, `reference\guide.md`

Unix スタイルのパスはすべてのプラットフォームで機能しますが、Windows スタイルの
パスは Unix システムでエラーを引き起こします。

### 多すぎる選択肢を提示しない

必要でない限り、複数のアプローチを提示しない:

**悪い例: 選択肢が多すぎる**（混乱する）:

「pypdf、または pdfplumber、または PyMuPDF、または pdf2image、または...を
使用できます」

**良い例: デフォルトを提供**（エスケープハッチ付き）:

「テキスト抽出には pdfplumber を使用:

```python
import pdfplumber
```

OCR が必要なスキャンされた PDF の場合は、代わりに pdf2image と pytesseract を
使用。」

## 上級: 実行可能コードを含むスキル

以下のセクションは、実行可能スクリプトを含むスキルに焦点を当てています。
スキルが markdown 指示のみを使用する場合は、チェックリストセクションに
スキップしてください。

### 問題を解決し、丸投げしない

スキルのスクリプトを書く際は、Claude に丸投げするのではなく、エラー条件を
処理します。

**良い例: 明示的にエラーを処理**:

```python
def process_file(path):
    """ファイルを処理し、存在しない場合は作成。"""
    try:
        with open(path) as f:
            return f.read()
    except FileNotFoundError:
        # 失敗する代わりにデフォルトコンテンツでファイルを作成
        print(f"ファイル {path} が見つかりません。デフォルトを作成")
        with open(path, 'w') as f:
            f.write('')
        return ''
    except PermissionError:
        # 失敗する代わりに代替を提供
        print(f"{path} にアクセスできません。デフォルトを使用")
        return ''
```

**悪い例: Claude に丸投げ**:

```python
def process_file(path):
    # 失敗して Claude に解決させる
    return open(path).read()
```

設定パラメータも、「ブードゥー定数」を避けるために正当化され文書化される
必要があります（Ousterhout の法則）。正しい値がわからない場合、Claude が
どうやって判断するでしょうか？

**良い例: 自己文書化**:

```python
# HTTP リクエストは通常 30 秒以内に完了
# より長いタイムアウトは遅い接続を考慮
REQUEST_TIMEOUT = 30

# 3 回のリトライは信頼性と速度のバランス
# ほとんどの断続的な失敗は 2 回目のリトライで解決
MAX_RETRIES = 3
```

**悪い例: マジックナンバー**:

```python
TIMEOUT = 47  # なぜ 47？
RETRIES = 5   # なぜ 5？
```

### ユーティリティスクリプトを提供

Claude がスクリプトを書けるとしても、事前に作成されたスクリプトには
利点があります:

**ユーティリティスクリプトの利点**:

- 生成されたコードより信頼性が高い
- トークンを節約（コンテキストにコードを含める必要がない）
- 時間を節約（コード生成が不要）
- 使用全体での一貫性を確保

指示で Claude が以下のどちらをすべきか明確にします:

- **スクリプトを実行**（最も一般的）: 「`analyze_form.py` を実行してフィールドを
  抽出」
- **参照として読む**（複雑なロジックの場合）: 「抽出アルゴリズムについては
  `analyze_form.py` を参照」

ほとんどのユーティリティスクリプトでは、実行が推奨されます。より信頼性が高く
効率的だからです。

**例**:

```markdown
## ユーティリティスクリプト

**analyze_form.py**: PDF からすべてのフォームフィールドを抽出

python scripts/analyze_form.py input.pdf > fields.json

出力形式:

{
  "field_name": {"type": "text", "x": 100, "y": 200},
  "signature": {"type": "sig", "x": 150, "y": 500}
}

**validate_boxes.py**: 重複するバウンディングボックスをチェック

python scripts/validate_boxes.py fields.json
# 返却: "OK" または競合をリスト

**fill_form.py**: PDF にフィールド値を適用

python scripts/fill_form.py input.pdf fields.json output.pdf
```

### 視覚的分析を使用

入力を画像としてレンダリングできる場合、Claude に分析させます:

```markdown
## フォームレイアウト分析

1. PDF を画像に変換:
   python scripts/pdf_to_images.py form.pdf

2. 各ページ画像を分析してフォームフィールドを特定
3. Claude はフィールドの位置と種類を視覚的に確認可能
```

Claude のビジョン機能は、レイアウトと構造を理解するのに役立ちます。

### 検証可能な中間出力を作成

Claude が複雑でオープンエンドなタスクを実行する際、間違いを犯す可能性があります。
「計画-検証-実行」パターンは、Claude にまず構造化された形式で計画を作成させ、
その計画をスクリプトで検証してから実行することで、エラーを早期にキャッチします。

**例**: スプレッドシートに基づいて PDF の 50 個のフォームフィールドを更新する
よう Claude に依頼したとします。検証がなければ、Claude は存在しないフィールドを
参照したり、競合する値を作成したり、必須フィールドを見逃したり、更新を誤って
適用したりする可能性があります。

**解決策**: 上記のワークフローパターン（PDF フォーム入力）を使用しますが、
変更を適用する前に検証される中間 `changes.json` ファイルを追加します。
ワークフローは次のようになります: 分析 → **計画ファイルを作成** → **計画を検証**
→ 実行 → 確認。

**このパターンが機能する理由:**

- **早期にエラーをキャッチ**: 変更が適用される前に検証で問題を発見
- **機械で検証可能**: スクリプトは客観的な検証を提供
- **可逆的な計画**: Claude はオリジナルに触れずに計画を反復可能
- **明確なデバッグ**: エラーメッセージが特定の問題を指摘

**使用するタイミング**: バッチ操作、破壊的な変更、複雑な検証ルール、
ハイステークスな操作。

**実装のヒント**: 検証スクリプトを「フィールド 'signature_date' が見つかりません。
利用可能なフィールド: customer_name, order_total, signature_date_signed」のような
具体的なエラーメッセージで詳細にして、Claude が問題を修正しやすくします。

### パッケージの依存関係

スキルは、プラットフォーム固有の制限があるコード実行環境で実行されます:

- **claude.ai**: npm と PyPI からパッケージをインストールし、GitHub リポジトリ
  からプルできる
- **Anthropic API**: ネットワークアクセスなし、ランタイムパッケージ
  インストールなし

SKILL.md に必要なパッケージをリストし、コード実行ツールのドキュメントで
利用可能であることを確認してください。

### ランタイム環境

スキルは、ファイルシステムアクセス、bash コマンド、コード実行機能を備えた
コード実行環境で実行されます。

**Claude がスキルにアクセスする方法:**

1. **メタデータが事前に読み込まれる**: 起動時に、すべてのスキルの YAML
   フロントマターからの名前と説明がシステムプロンプトに読み込まれる
2. **ファイルはオンデマンドで読み込まれる**: Claude は必要に応じて bash Read
   ツールを使用してファイルシステムから SKILL.md やその他のファイルにアクセス
3. **スクリプトは効率的に実行される**: ユーティリティスクリプトは、その完全な
   内容をコンテキストに読み込まずに bash 経由で実行可能。スクリプトの出力のみが
   トークンを消費
4. **大きなファイルにコンテキストペナルティなし**: 参照ファイル、データ、
   ドキュメントは、実際に読み込まれるまでコンテキストトークンを消費しない

**作成への影響:**

- **ファイルパスが重要**: Claude はスキルディレクトリをファイルシステムのように
  ナビゲート。スラッシュ（`reference/guide.md`）を使用し、バックスラッシュは
  使用しない
- **ファイルに説明的な名前を付ける**: 内容を示す名前を使用:
  `form_validation_rules.md`、`doc2.md` ではない
- **発見しやすいように整理**: ドメインまたは機能ごとにディレクトリを構造化
  - 良い: `reference/finance.md`, `reference/sales.md`
  - 悪い: `docs/file1.md`, `docs/file2.md`
- **包括的なリソースをバンドル**: 完全な API ドキュメント、広範な例、大きな
  データセットを含める; アクセスされるまでコンテキストペナルティなし
- **決定論的な操作にはスクリプトを優先**: Claude に検証コードを生成させるより
  `validate_form.py` を書く
- **実行の意図を明確にする**:
  - 「`analyze_form.py` を実行してフィールドを抽出」（実行）
  - 「抽出アルゴリズムについては `analyze_form.py` を参照」（参照として読む）
- **ファイルアクセスパターンをテスト**: 実際のリクエストでテストして、Claude が
  ディレクトリ構造をナビゲートできることを確認

**例:**

```txt
bigquery-skill/
├── SKILL.md (概要、参照ファイルを指す)
└── reference/
    ├── finance.md (収益指標)
    ├── sales.md (パイプラインデータ)
    └── product.md (使用状況分析)
```

ユーザーが収益について質問すると、Claude は SKILL.md を読み、
`reference/finance.md` への参照を確認し、bash を呼び出してそのファイルのみを
読み込みます。sales.md と product.md ファイルはファイルシステム上に残り、
必要になるまでコンテキストトークンをゼロ消費します。このファイルシステムベースの
モデルが段階的開示を可能にします。Claude は各タスクが必要とするものを正確に
ナビゲートして選択的に読み込むことができます。

### MCP ツール参照

スキルが MCP（Model Context Protocol）ツールを使用する場合、「ツールが
見つかりません」エラーを避けるために常に完全修飾ツール名を使用します。

**形式**: `ServerName:tool_name`

**例**:

```markdown
BigQuery:bigquery_schema ツールを使用してテーブルスキーマを取得。
GitHub:create_issue ツールを使用して issue を作成。
```

ここで:

- `BigQuery` と `GitHub` は MCP サーバー名
- `bigquery_schema` と `create_issue` はそれらのサーバー内のツール名

サーバープレフィックスがないと、特に複数の MCP サーバーが利用可能な場合、
Claude はツールを見つけられない可能性があります。

### ツールがインストールされていると仮定しない

パッケージが利用可能だと仮定しない:

**悪い例: インストールを仮定**:

「pdf ライブラリを使用してファイルを処理。」

**良い例: 依存関係を明示**:

「必要なパッケージをインストール: `pip install pypdf`

次に使用:

```python
from pypdf import PdfReader
reader = PdfReader("file.pdf")
```

」

## 効果的なスキルのチェックリスト

スキルを共有する前に確認:

### コア品質

- [ ] 説明が具体的でキーワードを含む
- [ ] 説明がスキルの機能と使用タイミングの両方を含む
- [ ] SKILL.md 本文が 500 行未満
- [ ] 追加の詳細が別ファイルにある（必要な場合）
- [ ] 時間依存情報がない（または「古いパターン」セクションにある）
- [ ] 全体で一貫した用語
- [ ] 例が具体的で抽象的でない
- [ ] ファイル参照が 1 レベルの深さ
- [ ] 段階的開示が適切に使用されている
- [ ] ワークフローに明確なステップがある

### コードとスクリプト

- [ ] スクリプトが問題を解決し、Claude に丸投げしない
- [ ] エラーハンドリングが明示的で役立つ
- [ ] 「ブードゥー定数」がない（すべての値が正当化されている）
- [ ] 必要なパッケージが指示にリストされ、利用可能であることが確認されている
- [ ] スクリプトに明確なドキュメントがある
- [ ] Windows スタイルのパスがない（すべてスラッシュ）
- [ ] 重要な操作の検証/確認ステップがある
- [ ] 品質が重要なタスクにフィードバックループが含まれている

### テスト

- [ ] 少なくとも 3 つの評価が作成されている
- [ ] Haiku、Sonnet、Opus でテスト済み
- [ ] 実際の使用シナリオでテスト済み
- [ ] チームのフィードバックが取り入れられている（該当する場合）
