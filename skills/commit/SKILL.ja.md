---
name: commit
description: 現在の git diff を確認し、プロジェクトの規約に従ったコミットメッセージを作成して git commit を実行する。ユーザーが変更のコミットを依頼したとき、作業が一区切りついたときに使用する。
translated_from: SKILL.md
---

# Commit

作業ツリーの変更内容を確認し、Conventional Commits 形式のコミットメッセージを作成してコミットを実行する。

## ワークフロー

### 1. 変更内容の確認

以下のコマンドを並列で実行し、現在の状態を把握する:

- `git status` — 変更ファイルと未追跡ファイルの特定
- `git diff` — ステージされていない変更の確認
- `git diff --staged` — ステージ済みの変更の確認
- `git log --oneline -5` — 直近のコミットスタイルの参照

コミットする変更がない場合、ユーザーに通知して終了する。

### 2. コミット分割の検討

変更内容を確認し、複数のコミットに分割すべきか判断する。以下のように論理的に独立した単位が含まれる場合、分割を提案する:

- 異なる機能やバグ修正
- 無関係なファイル群（例: ソースコード vs. 設定ファイル vs. ドキュメント）
- 異なるコミットタイプの変更（例: `skills` + `chore`）

分割が適切な場合、コミットごとのファイルとコミットメッセージの分割プランをユーザーに提示する。承認後、各コミットについてステップ 3-6 を順次実行する。

変更がまとまっており単一コミットで問題ない場合、そのまま進める。

### 3. ファイルのステージング

- `git add <file>...` で対象ファイルのみをステージングする
- ユーザーが明示的に指示しない限り `git add -A` や `git add .` は使用しない
- シークレットを含む可能性のあるファイル（`.env`、認証情報、トークン）はステージングしない

### 4. コミットメッセージの作成

`references/commit-rules.md` を読み、プロジェクトのコミットメッセージ規約に従ってメッセージを作成する。

主なルール:

- フォーマット: `<type>: <簡潔な要約>`
- 英語で記述する
- *何をしたか* だけでなく *なぜそうしたか* を要約する
- 理由やコンテキストが自明でない場合のみ、任意の本文（3行目以降）を追加する

### 5. ユーザーへの確認

提案するコミットメッセージとステージ済みファイルの一覧をユーザーに提示する。承認を得てから次に進む。変更の要望があれば修正し、再度確認する。

### 6. コミットの実行

承認されたメッセージで `git commit` を実行する。メッセージは HEREDOC で渡す:

```bash
git commit -m "$(cat <<'EOF'
<type>: <要約>

<任意の本文>
EOF
)"
```

コミット完了後、`git status` を実行して成功を確認し、結果を報告する。

## 重要事項

- ユーザーが明示的に指示しない限り、過去のコミットを amend しない
- ユーザーが明示的に指示しない限り、リモートへ push しない
- pre-commit hook が失敗した場合、問題を修正し再ステージングして **新しい** コミットを作成する（amend しない）

## リファレンス

- `references/commit-rules.md` — コミットメッセージのフォーマットとタイプ定義
