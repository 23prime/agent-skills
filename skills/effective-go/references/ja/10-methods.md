# Methods

## Pointers vs. Values

`ByteSize`で見たように、メソッドは任意の名前付き型(ポインタまたはインターフェースを除く)に対して定義できる。レシーバは構造体である必要はない。

上記のスライスの議論で、我々は`Append`関数を書いた。これを代わりにスライス上のメソッドとして定義できる。これを行うには、まずメソッドをバインドできる名前付き型を宣言し、次にメソッドのレシーバをその型の値にする。

```go
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // 本体は上で定義した Append 関数とまったく同じ。
}
```

これでもまだメソッドは更新されたスライスを返す必要がある。メソッドを再定義して`ByteSlice`への*ポインタ*をレシーバとして受け取るようにすれば、この不格好さを排除できる。これによりメソッドは呼び出し元のスライスを上書きできる。

```go
func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // 本体は上と同じだが、return はない。
    *p = slice
}
```

実際、さらに良くすることができる。関数を次のように標準的な`Write`メソッドのように見えるように修正すると、

```go
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // ここも上と同様。
    *p = slice
    return len(data), nil
}
```

その場合、型`*ByteSlice`は標準インターフェース`io.Writer`を満たす。これは便利である。例えば、これに出力することができる。

```go
var b ByteSlice
fmt.Fprintf(&b, "This hour has %d days\n", 7)
```

`*ByteSlice`のみが`io.Writer`を満たすため、`ByteSlice`のアドレスを渡す。レシーバに関するポインタ対値のルールは、値メソッドはポインタと値の両方で呼び出すことができるが、ポインタメソッドはポインタでのみ呼び出すことができるということである。

このルールが生じるのは、ポインタメソッドがレシーバを変更できるためである。値でそれらを呼び出すと、メソッドは値のコピーを受け取ることになるため、変更は破棄される。したがって言語はこの誤りを許可しない。ただし、便利な例外がある。値がアドレス可能な場合、言語は値に対してポインタメソッドを呼び出す一般的なケースを、自動的にアドレス演算子を挿入することで処理する。我々の例では、変数`b`はアドレス可能であるため、単に`b.Write`でその`Write`メソッドを呼び出せる。コンパイラはこれを`(&b).Write`に書き換える。

ところで、バイトスライスに対して`Write`を使用するというアイデアは、`bytes.Buffer`の実装の中心である。
