# Data

## new による割り当て

Goには2つの割り当てプリミティブがある。組み込み関数の`new`と`make`である。これらは異なることを行い、異なる型に適用されるため混乱を招く可能性があるが、ルールは単純である。

`new`はメモリを割り当てる組み込み関数であるが、他の言語の同名の関数とは異なり、メモリを*初期化*せず、*ゼロ化*するだけである。つまり、`new(T)`は型`T`の新しい項目に対してゼロ化されたストレージを割り当て、そのアドレス、すなわち型`*T`の値を返す。Goの用語では、型`T`の新しく割り当てられたゼロ値へのポインタを返す。

`new`によって返されるメモリはゼロ化されているため、データ構造を設計する際に各型のゼロ値をさらなる初期化なしで使用できるように配置すると便利である。これは、データ構造のユーザーが`new`で作成してすぐに使用できることを意味する。たとえば、`bytes.Buffer`のドキュメントには「`Buffer`のゼロ値は使用可能な空のバッファである」と記載されている。同様に、`sync.Mutex`には明示的なコンストラクタや`Init`メソッドがない。代わりに、`sync.Mutex`のゼロ値はアンロックされたmutexとして定義されている。

ゼロ値が有用であるという性質は推移的に機能する。次の型宣言を考えてみよう。

```go
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
```

型`SyncedBuffer`の値も、割り当てまたは単なる宣言の直後から使用できる。次のスニペットでは、`p`と`v`の両方がさらなる配置なしで正しく動作する。

```go
p := new(SyncedBuffer)  // *SyncedBuffer 型
var v SyncedBuffer      //  SyncedBuffer 型
```

## コンストラクタと複合リテラル

ゼロ値では不十分で、初期化コンストラクタが必要な場合がある。パッケージ`os`から派生した次の例を見てみよう。

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
```

ここには多くの定型コードがある。*複合リテラル*を使用して簡略化できる。複合リテラルは、評価されるたびに新しいインスタンスを作成する式である。

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &f
}
```

Cとは異なり、ローカル変数のアドレスを返すことは完全に問題ないことに注意してほしい。変数に関連付けられたストレージは、関数が戻った後も存続する。実際、複合リテラルのアドレスを取得すると、評価されるたびに新しいインスタンスが割り当てられるため、これら最後の2行を組み合わせることができる。

```go
return &File{fd, name, nil, 0}
```

複合リテラルのフィールドは順番に配置され、すべて存在する必要がある。ただし、要素に明示的に*フィールド*`:`*値*のペアとしてラベルを付けることで、初期化子を任意の順序で表示でき、欠落しているものはそれぞれのゼロ値として残される。したがって、次のように記述できる。

```go
return &File{fd: fd, name: name}
```

極端なケースとして、複合リテラルにフィールドがまったく含まれていない場合、その型のゼロ値が作成される。式`new(File)`と`&File{}`は等価である。

複合リテラルは、配列、スライス、マップに対しても作成でき、フィールドラベルは適切にインデックスまたはマップキーになる。次の例では、`Enone`、`Eio`、`Einval`の値が異なる限り、初期化は値に関係なく機能する。

```go
a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
```

## make による割り当て

組み込み関数`make(T, args)`は`new(T)`とは異なる目的を果たす。これはスライス、マップ、チャネルのみを作成し、型`T`の*初期化された*(*ゼロ化*されていない)値を返す(`*T`ではない)。この区別の理由は、これら3つの型が内部的に、使用前に初期化する必要があるデータ構造への参照を表しているためである。たとえば、スライスは、データへのポインタ(配列内)、長さ、容量を含む3項目のディスクリプタであり、これらの項目が初期化されるまで、スライスは`nil`である。スライス、マップ、チャネルの場合、`make`は内部データ構造を初期化し、使用する値を準備する。たとえば、次のようになる。

```go
make([]int, 10, 100)
```

これは100個のintの配列を割り当て、長さ10、容量100のスライス構造を作成し、配列の最初の10要素を指す。(スライスを作成する際、容量は省略できる。詳細については、スライスのセクションを参照。)対照的に、`new([]int)`は新しく割り当てられたゼロ化されたスライス構造へのポインタ、つまり`nil`スライス値へのポインタを返す。

これらの例は、`new`と`make`の違いを示している。

```go
var p *[]int = new([]int)       // スライス構造体を割り当てる。*p == nil となり、ほとんど使われない
var v  []int = make([]int, 100) // スライス v は100個の int からなる新しい配列を参照する

// 不必要に複雑:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// 慣用的:
v := make([]int, 100)
```

`make`はマップ、スライス、チャネルにのみ適用され、ポインタを返さないことを覚えておいてほしい。明示的なポインタを取得するには、`new`で割り当てるか、変数のアドレスを明示的に取得する。

## 配列

配列は、メモリの詳細なレイアウトを計画する際に役立ち、割り当てを回避するのに役立つこともあるが、主に次のセクションの主題であるスライスの構成要素である。

Goでは次のようになる。

- 配列は値である。ある配列を別の配列に割り当てると、すべての要素がコピーされる。
- 特に、配列を関数に渡すと、関数は配列へのポインタではなく、配列の*コピー*を受け取る。
- 配列のサイズは型の一部である。型`[10]int`と`[20]int`は異なる。

値プロパティは有用であるが、コストもかかる。C言語のような動作と効率を求める場合は、配列へのポインタを渡すことができる。

```go
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // 明示的なアドレス演算子に注意
```

しかし、このスタイルでさえ慣用的なGoではない。代わりにスライスを使用する。

## スライス

スライスは配列をラップして、データシーケンスに対してより一般的で強力で便利なインターフェースを提供する。変換行列などの明示的な次元を持つ項目を除き、Goのほとんどの配列プログラミングは、単純な配列ではなくスライスで行われる。

スライスは基底配列への参照を保持しており、あるスライスを別のスライスに割り当てると、両方とも同じ配列を参照する。関数がスライス引数を受け取る場合、スライスの要素に加えた変更は呼び出し元に表示される。これは、基底配列へのポインタを渡すことに似ている。したがって、`Read`関数は、ポインタとカウントではなく、スライス引数を受け入れることができる。スライス内の長さは、読み取るデータ量の上限を設定する。次は、パッケージ`os`の`File`型の`Read`メソッドのシグネチャである。

```go
func (f *File) Read(buf []byte) (n int, err error)
```

このメソッドは、読み取られたバイト数とエラー値(ある場合)を返す。より大きなバッファ`buf`の最初の32バイトに読み取るには、バッファを*スライス*(ここでは動詞として使用)する。

```go
n, err := f.Read(buf[0:32])
```

このようなスライスは一般的で効率的である。スライスの長さは、基底配列の制限内に収まる限り変更できる。それ自体のスライスに割り当てるだけでよい。組み込み関数`cap`でアクセスできるスライスの*容量*は、スライスが取りうる最大長を報告する。次は、スライスにデータを追加する関数である。データが容量を超える場合、スライスは再割り当てされる。結果のスライスが返される。

```go
func Append(slice, data []byte) []byte {
    l := len(slice)
    if l + len(data) > cap(slice) {  // 再割り当て
        // 将来の拡張に備え、必要量の2倍を割り当てる。
        newSlice := make([]byte, (l+len(data))*2)
        // copy 関数は組み込みであり、任意のスライス型で動作する。
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    copy(slice[l:], data)
    return slice
}
```

`Append`は`slice`の要素を変更できるが、スライス自体(ポインタ、長さ、容量を保持する実行時データ構造)は値渡しされるため、その後スライスを返す必要がある。

スライスに追加するという考え方は非常に有用であるため、組み込み関数`append`によって実現されている。

## 二次元スライス

Goの配列とスライスは一次元である。2D配列またはスライスに相当するものを作成するには、次のように配列の配列またはスライスのスライスを定義する必要がある。

```go
type Transform [3][3]float64  // 3x3 の配列。実際には配列の配列。
type LinesOfText [][]byte     // バイトスライスのスライス。
```

スライスは可変長であるため、各内部スライスを異なる長さにすることができる。

```go
text := LinesOfText{
    []byte("Now is the time"),
    []byte("for all good gophers"),
    []byte("to bring some fun to the party."),
}
```

2Dスライスを割り当てる必要がある場合がある。たとえば、ピクセルのスキャンラインを処理する場合などである。これを実現するには2つの方法がある。1つは各スライスを独立して割り当てる方法、もう1つは単一の配列を割り当ててそれに個々のスライスを指す方法である。

まず、一度に1行ずつ。

```go
// トップレベルのスライスを割り当てる。
picture := make([][]uint8, YSize) // y の各単位に1行。
// 各行をループし、各行のスライスを割り当てる。
for i := range picture {
    picture[i] = make([]uint8, XSize)
}
```

そして、1回の割り当てとして、行にスライスする。

```go
// トップレベルのスライスを割り当てる(上と同じ)。
picture := make([][]uint8, YSize) // y の各単位に1行。
// 全ピクセルを保持する大きなスライスを1つ割り当てる。
pixels := make([]uint8, XSize*YSize) // picture は [][]uint8 だが、型は []uint8。
// 各行をループし、残りの pixels スライスの先頭から各行をスライスする。
for i := range picture {
    picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
```

## マップ

マップは、ある型の値(*キー*)を別の型の値(*要素*または*値*)に関連付ける便利で強力な組み込みデータ構造である。キーは、等価演算子が定義されている任意の型、たとえば整数、浮動小数点数、複素数、文字列、ポインタ、インターフェース(動的型が等価性をサポートする限り)、構造体、配列にすることができる。スライスは等価性が定義されていないため、マップキーとして使用できない。スライスと同様に、マップは基底データ構造への参照を保持する。

マップは、コロンで区切られたキーと値のペアを使用して、通常の複合リテラル構文で構築できる。

```go
var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
```

マップ値の割り当てと取得は、配列やスライスの場合と構文的に同じように見えるが、インデックスが整数である必要がない点が異なる。

```go
offset := timeZone["EST"]
```

マップに存在しないキーでマップ値を取得しようとすると、マップ内のエントリの型のゼロ値が返される。値の型が`bool`のマップとして集合を実装できる。

欠落しているエントリとゼロ値を区別する必要がある場合がある。複数代入の形式で識別できる。

```go
var seconds int
var ok bool
seconds, ok = timeZone[tz]
```

明らかな理由により、これは「comma ok」イディオムと呼ばれる。次は、これを適切なエラーレポートと組み合わせた関数である。

```go
func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
```

実際の値を気にせずにマップ内の存在をテストするには、値の通常の変数の代わりにブランク識別子(`_`)を使用できる。

```go
_, present := timeZone[tz]
```

マップエントリを削除するには、組み込み関数`delete`を使用する。引数はマップと削除するキーである。キーがマップにすでに存在しない場合でも、これを行うのは安全である。

```go
delete(timeZone, "PDT")  // 標準時に戻す
```

## 出力

Goのフォーマット出力は、Cの`printf`ファミリに似たスタイルを使用するが、より豊富で一般的である。関数は`fmt`パッケージに存在し、大文字の名前を持つ。`fmt.Printf`、`fmt.Fprintf`、`fmt.Sprintf`などである。文字列関数(`Sprintf`など)は、提供されたバッファに入力するのではなく、文字列を返す。

フォーマット文字列を提供する必要はない。`Printf`、`Fprintf`、`Sprintf`のそれぞれに対して、たとえば`Print`や`Println`などの別の関数のペアがある。これらの関数はフォーマット文字列を受け取らず、代わりに各引数のデフォルトフォーマットを生成する。

```go
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
```

フォーマット出力関数`fmt.Fprint`などは、`io.Writer`インターフェースを実装する任意のオブジェクトを最初の引数として受け取る。変数`os.Stdout`と`os.Stderr`は馴染みのあるインスタンスである。

整数に対する10進数など、デフォルトの変換だけが必要な場合は、汎用フォーマット`%v`(「value」の意)を使用できる。結果は`Print`と`Println`が生成するものと正確に同じである。さらに、このフォーマットは配列、スライス、構造体、マップなど*任意*の値を出力できる。

構造体を出力する際、変更されたフォーマット`%+v`は構造体のフィールドに名前で注釈を付け、任意の値に対して代替フォーマット`%#v`は完全なGo構文で値を出力する。

```go
type T struct {
    a int
    b float64
    c string
}
t := &T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
```

出力は次のようになる。

```text
&{7 -2.35 abc   def}
&{a:7 b:-2.35 c:abc    def}
&main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string]int{"CST":-21600, "EST":-18000, "MST":-25200, "PST":-28800, "UTC":0}
```

もう1つの便利なフォーマットは`%T`で、値の*型*を出力する。

```go
fmt.Printf("%T\n", timeZone)
```

出力は次のようになる。

```text
map[string]int
```

カスタム型のデフォルトフォーマットを制御したい場合は、型にシグネチャ`String() string`のメソッドを定義するだけでよい。

```go
func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
```

`String`メソッド内で無限に再帰する方法で`Sprintf`を呼び出して`String`メソッドを構築してはいけない。

```go
type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m) // エラー: 無限再帰する。
}
```

これは簡単に修正できる。引数をメソッドを持たない基本的な文字列型に変換する。

```go
type MyString string
func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", string(m)) // OK: 型変換に注意。
}
```

## Append

組み込み関数`append`は、スライスの末尾に要素を追加し、結果を返す。基底配列が変更される可能性があるため、結果を返す必要がある。

```go
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
```

出力は`[1 2 3 4 5 6]`である。

スライスをスライスに追加するには、呼び出しサイトで`...`を使用する。

```go
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
```

`...`がないと、型が間違っているためコンパイルされない。`y`は型`int`ではない。
