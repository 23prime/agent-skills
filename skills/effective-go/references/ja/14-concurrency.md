# 並行性

## 通信による共有

多くの環境において並行プログラミングは、共有変数への正しいアクセスを実装するために必要な微妙な配慮によって困難になっている。Goは異なるアプローチを推奨する。共有される値はチャネル上で受け渡され、実際には別々の実行スレッドによって積極的に共有されることはない。任意の時点で、ただ1つのgoroutineだけがその値へのアクセス権を持つ。設計上、データ競合は発生し得ない。この考え方を奨励するために、我々はそれをスローガンに凝縮した。

> メモリを共有することで通信するな。代わりに、通信することでメモリを共有せよ。

このアプローチは行き過ぎることもある。例えば、参照カウントは整数変数をmutexで囲むのが最良の方法かもしれない。しかし高レベルなアプローチとして、チャネルを使ってアクセスを制御することで、明確で正しいプログラムを書くことが容易になる。

このモデルについて考える1つの方法は、1つのCPU上で動作する典型的なシングルスレッドプログラムを考えることである。それは同期プリミティブを必要としない。今、もう1つの同様のインスタンスを実行する。それもまた同期を必要としない。今、それら2つに通信させる。もし通信が同期装置であるなら、他の同期は依然として不要である。例えばUnixパイプラインは、このモデルに完全に適合する。Goの並行性へのアプローチはHoareのCommunicating Sequential Processes(CSP)に起源を持つが、Unixパイプの型安全な一般化としても見ることができる。

## Goroutine

それらが*goroutine*と呼ばれるのは、既存の用語―スレッド、コルーチン、プロセスなど―が不正確な含意を伝えるためである。goroutineは単純なモデルを持つ。それは同じアドレス空間内で他のgoroutineと並行に実行される関数である。それは軽量で、スタック空間の割り当て以上のコストはほとんどかからない。そしてスタックは小さく開始するため安価であり、必要に応じてヒープストレージを割り当てる(および解放する)ことで成長する。

Goroutineは複数のOSスレッド上に多重化されるため、1つがブロックした場合―例えばI/Oを待っている間―他は実行を継続する。その設計はスレッド作成と管理の複雑さの多くを隠蔽する。

関数またはメソッド呼び出しに`go`キーワードを前置すると、その呼び出しが新しいgoroutineで実行される。呼び出しが完了すると、goroutineは静かに終了する。

```go
go list.Sort()  // list.Sort を並行に実行する。完了を待たない。
```

関数リテラルはgoroutine呼び出しにおいて便利である。

```go
func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // 括弧に注意 - 関数を呼び出す必要がある。
}
```

Goにおいて、関数リテラルはクロージャである。実装は、関数によって参照される変数が、それらがアクティブである限り生存することを保証する。

これらの例はあまり実用的ではない。なぜなら関数が完了をシグナルする方法を持たないからである。そのために、我々はチャネルを必要とする。

## チャネル

マップと同様に、チャネルは`make`で割り当てられ、結果の値は基礎となるデータ構造への参照として機能する。オプションの整数パラメータが提供されると、それはチャネルのバッファサイズを設定する。デフォルトはゼロで、バッファなしまたは同期的なチャネルとなる。

```go
ci := make(chan int)            // バッファなしの整数チャネル
cj := make(chan int, 0)         // バッファなしの整数チャネル
cs := make(chan *os.File, 100)  // バッファ付きの File ポインタチャネル
```

バッファなしチャネルは、通信―値の交換―と同期―2つの計算(goroutine)が既知の状態にあることを保証する―を組み合わせる。

チャネルを使った多くの優れたイディオムがある。これが手始めの1つである。チャネルは、起動するgoroutineがソートの完了を待つことを可能にする。

```go
c := make(chan int)  // チャネルを割り当てる。
// ゴルーチンでソートを開始する。完了したらチャネルにシグナルを送る。
go func() {
    list.Sort()
    c <- 1  // シグナルを送る。値は重要ではない。
}()
doSomethingForAWhile()
<-c   // ソートの完了を待つ。送信された値は破棄する。
```

受信側は、受信するデータがあるまで常にブロックする。チャネルがバッファなしの場合、送信側は受信側が値を受信するまでブロックする。チャネルがバッファを持つ場合、送信側は値がバッファにコピーされるまでのみブロックする。バッファが満杯の場合、これはある受信側が値を取り出すまで待つことを意味する。

バッファ付きチャネルは、例えばスループットを制限するために、セマフォのように使用できる。

```go
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem <- 1    // アクティブキューが空くのを待つ。
    process(r)  // 時間がかかる場合がある。
    <-sem       // 完了。次のリクエストの実行を許可する。
}

func Serve(queue chan *Request) {
    for {
        req := <-queue
        go handle(req)  // handle の完了を待たない。
    }
}
```

しかしこの設計には問題がある。`Serve`は入ってくるリクエストごとに新しいgoroutineを作成するが、実際には任意の時点で`MaxOutstanding`個のみが実行できる。goroutineの作成をゲートするように`Serve`を変更することで、その欠陥に対処できる。

```go
func Serve(queue chan *Request) {
    for req := range queue {
        sem <- 1
        go func() {
            process(req)
            <-sem
        }()
    }
}
```

リソースをうまく管理する別のアプローチは、固定数の`handle` goroutineを起動し、すべてがリクエストチャネルから読み取るようにすることである。

```go
func handle(queue chan *Request) {
    for r := range queue {
        process(r)
    }
}

func Serve(clientRequests chan *Request, quit chan bool) {
    // ハンドラを起動する
    for i := 0; i < MaxOutstanding; i++ {
        go handle(clientRequests)
    }
    <-quit  // 終了の指示を待つ。
}
```

## チャネルのチャネル

Goの最も重要な特性の1つは、チャネルが第一級の値であり、他のものと同様に割り当てて受け渡しできることである。この特性の一般的な使用法は、安全で並列な逆多重化を実装することである。

その型が応答用のチャネルを含む場合、各クライアントは答えのための独自のパスを提供できる。

```go
type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
```

クライアントは関数とその引数を提供し、加えてリクエストオブジェクト内に答えを受信するためのチャネルを提供する。

```go
func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &Request{[]int{3, 4, 5}, sum, make(chan int)}
// リクエストを送信する
clientRequests <- request
// レスポンスを待つ。
fmt.Printf("answer: %d\n", <-request.resultChan)
```

サーバー側では、ハンドラ関数だけが変更される。

```go
func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan <- req.f(req.args)
    }
}
```

## 並列化

これらのアイデアのもう1つの応用は、複数のCPUコア間で計算を並列化することである。計算が独立に実行できる個別の部分に分割できる場合、それは並列化でき、各部分が完了したときにシグナルを送るチャネルを使う。

```go
type Vector []float64

// v[i], v[i+1] ... v[n-1] に演算を適用する。
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i < n; i++ {
        v[i] += u.Op(v[i])
    }
    c <- 1    // この部分が完了したことを通知する
}
```

ループ内で部分を独立して起動する。CPU毎に1つずつ。

```go
const numCPU = 4 // CPU コア数

func (v Vector) DoAll(u Vector) {
    c := make(chan int, numCPU)  // バッファリングは任意だが合理的。
    for i := 0; i < numCPU; i++ {
        go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c)
    }
    // チャネルを読み出す。
    for i := 0; i < numCPU; i++ {
        <-c    // 1つのタスクの完了を待つ
    }
    // すべて完了。
}
```

numCPUの定数値を作成するのではなく、ランタイムにどの値が適切かを尋ねることができる。

```go
var numCPU = runtime.NumCPU()
```

また、`runtime.GOMAXPROCS()`という関数もあり、Goプログラムが同時に実行できるユーザー指定のコア数を報告する(または設定する)。

```go
var numCPU = runtime.GOMAXPROCS(0)
```

並行性―独立して実行するコンポーネントとしてプログラムを構造化すること―と並列性―複数のCPU上で効率的に計算を並列に実行すること―の概念を混同しないように注意せよ。Goの並行性機能は一部の問題を並列計算として構造化することを容易にできるが、Goは並行言語であって並列言語ではなく、すべての並列化問題がGoのモデルに適合するわけではない。

## リーキーバッファ

並行プログラミングのツールは、非並行的なアイデアさえも表現しやすくすることができる。これはRPCパッケージから抽象化された例である。クライアントgoroutineはループして、ある情報源―おそらくネットワーク―からデータを受信する。バッファの割り当てと解放を避けるために、フリーリストを保持し、それを表すためにバッファ付きチャネルを使用する。

```go
var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        // 利用可能なバッファがあれば取得し、なければ新規に割り当てる。
        select {
        case b = <-freeList:
            // 取得できた。他に何もしない。
        default:
            // 空きなし。新しいバッファを割り当てる。
            b = new(Buffer)
        }
        load(b)              // ネットワークから次のメッセージを読み込む。
        serverChan <- b      // サーバーに送信する。
    }
}
```

サーバーループはクライアントから各メッセージを受信し、処理して、バッファをフリーリストに返す。

```go
func server() {
    for {
        b := <-serverChan    // 処理を待つ。
        process(b)
        // 空きがあればバッファを再利用する。
        select {
        case freeList <- b:
            // フリーリストにバッファを戻した。他に何もしない。
        default:
            // フリーリストが満杯。そのまま続行する。
        }
    }
}
```

クライアントは`freeList`からバッファを取得しようと試みる。利用可能なものがなければ、新しいものを割り当てる。サーバーの`freeList`への送信は、リストが満杯でない限り`b`をフリーリストに戻す。満杯の場合、バッファはガベージコレクタによって回収されるために破棄される。(`select`文の`default`節は、他のケースが準備できていないときに実行され、`select`が決してブロックしないことを意味する。)この実装は、バッファ付きチャネルとガベージコレクタに簿記を頼ることで、わずか数行でリーキーバケットフリーリストを構築する。
