# ブランク識別子

ブランク識別子（`_`）は、あらゆる型のあらゆる値を代入または宣言でき、その値は無害に破棄される。これはUnixの`/dev/null`ファイルへの書き込みに似ている。変数が必要だが実際の値は無関係な場合に、プレースホルダーとして使用される書き込み専用の値を表す。

## 多重代入におけるブランク識別子

ブランク識別子は、不要な戻り値を破棄するために多重代入の状況で使用される。

```go
if _, err := os.Stat(path); os.IsNotExist(err) {
    fmt.Printf("%s does not exist\n", path)
}
```

**重要:** エラーを無視するためにエラー値を破棄することは避ける。常にエラーの戻り値をチェックすること。

```go
// 悪い例! path が存在しない場合このコードはクラッシュする。
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf("%s is a directory\n", path)
}
```

## 未使用のimportと変数

パッケージをimportしたり変数を宣言したりして、それらを使用しないのはエラーである。未使用のimportはプログラムを肥大化させ、コンパイルを遅くする。プログラムが活発に開発中の場合、ブランク識別子は回避策を提供する。

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

var _ = fmt.Printf // デバッグ用。完了したら削除する。
var _ io.Reader    // デバッグ用。完了したら削除する。

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: fd を使用する。
    _ = fd
}
```

慣例により、importエラーを抑制するためのグローバル宣言は、import文の直後に配置し、コメントを付けるべきである。これにより見つけやすくなり、後で整理する必要があることを思い出させる。

## 副作用のためのimport

パッケージを明示的に使用せず、その副作用のためだけにimportすることが有用な場合がある。例えば、`net/http/pprof`パッケージは、その`init`関数の実行中にデバッグ情報を提供するHTTPハンドラを登録する。パッケージをその副作用のためだけにimportするには、それをブランク識別子にリネームする。

```go
import _ "net/http/pprof"
```

このimport形式は、パッケージがその副作用のためにimportされていることを明確にする。なぜなら、パッケージの他の使用方法が存在しないからである。このファイルでは、そのパッケージは名前を持たない。

## インターフェースチェック

型がインターフェースを実装していることを明示的に宣言する必要はない。代わりに、型はそのメソッドを実装するだけでインターフェースを実装する。ほとんどのインターフェース変換は静的であり、コンパイル時にチェックされる。しかし、一部のインターフェースチェックは実行時に発生する。

パッケージ内で型が実際にインターフェースを満たすことを保証する必要がある場合、ブランク識別子を使用したグローバル宣言を使用する。

```go
var _ json.Marshaler = (*RawMessage)(nil)
```

この宣言では、`*RawMessage`から`Marshaler`への変換を伴う代入により、`*RawMessage`が`Marshaler`を実装することが要求され、このプロパティはコンパイル時にチェックされる。もし`json.Marshaler`インターフェースが変更された場合、このパッケージはコンパイルできなくなり、更新が必要であることが通知される。

この構文におけるブランク識別子の出現は、この宣言が型チェックのためだけに存在し、変数を作成するためではないことを示している。慣例により、このような宣言は、コード内に静的変換がまだ存在しない場合にのみ使用される。これは稀な出来事である。
